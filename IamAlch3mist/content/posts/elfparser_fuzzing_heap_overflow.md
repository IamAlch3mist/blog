+++
title = "ELF Parsing Gone Wrong: A Journey from Fuzzing to Heap Overflow's"
date = "2025-03-19T20:05:51+05:30"
author = "IamAlch3mist"
authorTwitter = "" #do not include @
cover = ""
tags = ["Fuzzing", "AFL++", "heap overflows"]
keywords = ["", ""]
description = "During my fuzzing of random gitHub projects, I identified a heap overflow in an ELF parser"
showFullContent = false
readingTime = true
hideComments = false
color = "" #color from the theme settings
draft = true
+++

# Introduction 

I started fuzzing some random applications from github hoping to get some CVE, so rather than targetting a complex application like PDF parsers I opted to start with simple applications. As bugs could be found in parsing logic so I started the hunt with parsers for ELF, JSON, XML, etc. I choose this elf-parser https://github.com/TheCodeArtist/elf-parser to start with. 

* Not much code (so i get good coverage in my low spec laptop)
* ELF file format is well documented 
* 9 years old project so lots of bugy code 

I hope you already have an idea about fuzzing I don't want to bore you with explaining the theory behind it i recommend checking the AFL docs, this blog is not a fuzzing 101 tutorial i'm going to document my processs as i learn fuzzing and how i set up the fuzzing enviroment for the elf parser and fuzzing with the well know AFL++ fuzzer and triage analysis of few bugs i found.

# Fuzzing setup 

I choose AFL++ as my fuzzer, because in my opinion it's easier to get started, I'm not really fuzzing a library so i din't neeed fancy in-process fuzzer like LibFuzzer. Download the latest version of AFL++ at the time of writting v4.31 was the latest i used. Follow the below instructions to install AFL++. All test's been ran in a 2022.04 ubuntu environment with a 6 core cpu. 

```bash
sudo apt-get update && sudo apt upgrade
sudo apt-get install -y lld-16 llvm-18 llvm-18-dev clang-18 || sudo apt-get install -y lld llvm llvm-dev clang
sudo apt-get install -y gcc-$(gcc --version|head -n1|sed 's/\..*//'|sed 's/.* //')-plugin-dev libstdc++-$(gcc --version|head -n1|sed 's/\..*//'|sed 's/.* //')-dev
sudo apt-get install -y ninja-build # for QEMU mode
sudo apt-get install -y cpio libcapstone-dev llvm-18
sudo apt-get install -y gcc-10-plugin-dev

```

```bash
wget https://github.com/AFLplusplus/AFLplusplus/archive/refs/tags/v4.31c.tar.gz
tar xfv v4.31c.tar.gz
cd AFLplusplus-4.31c/
sudo make install
```

This steps will install AFL++ in our linux system. Now we are ready to fuzz with AFL++. If AFL++ compiled properly youll notice similar output. 

[Image for AFL BUILD]
#### Instrumenting elf-parser

Instrumentation is crucial for a feedback driven fuzzer like AFL++ to collect the coverage information from the target. Basically it's about adding tiny snippets of code to trace the basic blocks executed. It helps the fuzzer to identify whether a new code block has been hit. 

```bash
git clone https://github.com/TheCodeArtist/elf-parser
```

After cloning the target application i stared looking for the build config file basically make file.
 
```Makefile
cat Makefile

CC=gcc
CFLAGS= -Wall -g -I.
DEPS = elf-parser.h
OBJ = disasm.o elf-parser.o elf-parser-main.o

%.o: %.c $(DEPS)
        $(CC) -c -o $@ $< $(CFLAGS)

elfparser: $(OBJ)
        gcc -o $@ $^ $(CFLAGS)

clean:
        rm -rf *.o elfparser
```

gcc compiler is used to compile the application, and there is not much compiler flags we have to deal with. 

```Makefile
CC=afl-clang-lto
CFLAGS= -Wall -g -I.
DEPS = elf-parser.h
OBJ = disasm.o elf-parser.o elf-parser-main.o

%.o: %.c $(DEPS)
        $(CC) -c -o $@ $< $(CFLAGS)

elfparser: $(OBJ)
        afl-clang-lto -o $@ $^ $(CFLAGS)

clean:
        rm -rf *.o elfparser

```

I made some modifications to the make files, rather than using the default compiler we need to use the compiler from AFL++. I used **afl-clang-lto** for less overhead and better coverage to compile the target applciation. executing make will compile the application. Additionally i didn't used persistent mode or parallel fuzzing, it's for future blogs. 


#### Fuzzing elf-parser 
```bash
make
mkdir ins outs
```


Fuzzing requires corpus basically inputs to feed to the target. AFL++ requires a seperate directory to store the corpus files I named as ins to store the input elf binary files and we need a outs derectory to keep the crash files that's generated by fuzzer later required for ccrash triage analysis. 

The corpus file im using as initial seed. 

```bash
file ins/corpus1.bin
ins/corpus1.bin: ELF 32-bit LSB pie executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /usr/lib/ld-linux-armhf.so.3, BuildID[sha1]=022a470069956b4e5b7d48e051a5fd2305a1ae59, for GNU/Linux 3.2.0, stripped
```

Disable the core file to avoid the anoying crash report from ubuntu.
 
```bash
sudo su
echo core | sudo tee /proc/sys/kernel/core_pattern
cd /sys/devices/system/cpu
echo performance | tee cpu*/cpufreq/scaling_governor
```

This will start the AFL++ to start fuzzing elfparser and you could see the beautiful AFL++ fuzzer at action and in a minute it already found around 30+ crashes. 

```bash
afl-fuzz -i ins/ -o outs/ -- ./elfparser @@
```

[Image for AFL FUZZ]

I ran the fuzzer an entire night when i woke up morning the next day to find after 6 hours there are no new path have been found so i was confident enough to stop the fuzzer and started the triage analysis i got nearly 70+ crashes.

# AddressSanitizer 

Address sanitizer is used to detect bugs at run time especially for bugs like stack/heap buffer overflows, use-after-free, memory leaks etc. 

ASAN or other sanitizers make the crash triage analysis process less pain full than debugging in gdb without a context. UBSan covered in an upcoming blog. 

To enable ASAN I added the below flags in the makefile and recompiled with make again. 


```Makefile
CFLAGS= -Wall -g -I. -fsanitize=address
```


Without ASAN any crash on the application will look like a segfault, we won't know the exact cause for it. 

[CRASH IMAGE WO ASAN]


With ASAN enabled we get a 


# Crash triaging 

```c
find out/default/crashes/ -type f -exec ./elfparser {} \; > crashes.txt
```
